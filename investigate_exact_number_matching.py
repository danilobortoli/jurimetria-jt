#!/usr/bin/env python3
"""
Investiga√ß√£o de Matching por N√∫meros Exatos
Verifica por que n√£o encontramos o mesmo n√∫mero de processo nas tr√™s inst√¢ncias.
"""

import csv
from collections import defaultdict
import json

class ExactNumberMatcher:
    """Investiga matching exato de n√∫meros processuais."""
    
    def __init__(self):
        self.output_path = "exact_matching_results"
        import os
        os.makedirs(self.output_path, exist_ok=True)
    
    def load_data(self, csv_file):
        """Carrega dados de ass√©dio moral."""
        print("üìÇ Carregando dados para investiga√ß√£o de n√∫meros exatos...")
        
        all_cases = []
        with open(csv_file, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                if row['eh_assedio_moral'] == 'True':
                    all_cases.append(row)
        
        print(f"‚úÖ Carregados {len(all_cases):,} casos de ass√©dio moral")
        return all_cases
    
    def investigate_exact_number_matches(self, cases):
        """Investiga matches por n√∫mero exato."""
        print("\nüîç INVESTIGA√á√ÉO DE N√öMEROS EXATOS")
        print("=" * 50)
        
        # Organiza por n√∫mero de processo exato
        by_exact_number = defaultdict(list)
        for case in cases:
            numero = case['numero_processo']
            by_exact_number[numero].append(case)
        
        # Estat√≠sticas
        total_numbers = len(by_exact_number)
        multi_instance_numbers = {num: cases for num, cases in by_exact_number.items() if len(cases) > 1}
        
        print(f"Total de n√∫meros √∫nicos: {total_numbers:,}")
        print(f"N√∫meros em m√∫ltiplas inst√¢ncias: {len(multi_instance_numbers):,}")
        
        # Analisa os casos de m√∫ltiplas inst√¢ncias
        chain_patterns = defaultdict(int)
        examples = defaultdict(list)
        
        print(f"\nüìã AN√ÅLISE DETALHADA DOS PRIMEIROS 20 CASOS MULTI-INST√ÇNCIA:")
        print("=" * 60)
        
        for i, (numero, cases_list) in enumerate(list(multi_instance_numbers.items())[:20]):
            graus = [case['grau'] for case in cases_list]
            tribunais = [case['tribunal'] for case in cases_list]
            unique_graus = sorted(set(graus))
            chain_pattern = "‚Üí".join(unique_graus)
            
            chain_patterns[chain_pattern] += 1
            if len(examples[chain_pattern]) < 3:
                examples[chain_pattern].append((numero, cases_list))
            
            print(f"\n{i+1}. N√∫mero: {numero}")
            print(f"   Inst√¢ncias: {chain_pattern}")
            print(f"   Tribunais: {', '.join(set(tribunais))}")
            
            for case in cases_list:
                instancia = case.get('instancia_normalizada', 'N/A')
                arquivo = case.get('arquivo_origem', 'N/A')
                print(f"   - {case['grau']}: {case['tribunal']} | {instancia} | {arquivo}")
            
            # Verifica se √© cadeia completa G1‚ÜíG2‚ÜíSUP
            if 'G1' in unique_graus and 'G2' in unique_graus and 'SUP' in unique_graus:
                print("   üéâ CADEIA COMPLETA G1‚ÜíG2‚ÜíTST!")
        
        # Resumo dos padr√µes
        print(f"\nüìä PADR√ïES DE CADEIA ENCONTRADOS:")
        print("=" * 40)
        for pattern, count in sorted(chain_patterns.items(), key=lambda x: x[1], reverse=True):
            percent = (count / len(multi_instance_numbers)) * 100 if len(multi_instance_numbers) > 0 else 0
            print(f"  {pattern}: {count:,} ({percent:.1f}%)")
        
        # Conta cadeias completas
        complete_chains = chain_patterns.get('G1‚ÜíG2‚ÜíSUP', 0)
        print(f"\nüèÜ CADEIAS COMPLETAS G1‚ÜíG2‚ÜíTST: {complete_chains}")
        
        return {
            'total_numbers': total_numbers,
            'multi_instance_count': len(multi_instance_numbers),
            'chain_patterns': dict(chain_patterns),
            'complete_chains': complete_chains,
            'examples': dict(examples)
        }
    
    def analyze_number_variations(self, cases):
        """Analisa varia√ß√µes sutis nos n√∫meros."""
        print(f"\nüîç AN√ÅLISE DE VARIA√á√ïES SUTIS NOS N√öMEROS")
        print("=" * 50)
        
        # Agrupa por n√∫mero base (removendo pequenas varia√ß√µes)
        base_numbers = defaultdict(list)
        
        for case in cases:
            numero = case['numero_processo']
            # Remove caracteres n√£o num√©ricos e pontua√ß√£o
            base = ''.join(filter(str.isdigit, numero))
            base_numbers[base].append(case)
        
        # Encontra casos onde o n√∫mero base √© igual mas h√° varia√ß√µes
        variations = {}
        for base, cases_list in base_numbers.items():
            if len(cases_list) > 1:
                # Verifica se h√° n√∫meros diferentes com mesmo base
                different_numbers = set(case['numero_processo'] for case in cases_list)
                if len(different_numbers) > 1:
                    variations[base] = {
                        'numbers': list(different_numbers),
                        'cases': cases_list
                    }
        
        print(f"N√∫meros base com varia√ß√µes: {len(variations)}")
        
        if variations:
            print(f"\nPrimeiros 10 exemplos de varia√ß√µes:")
            for i, (base, info) in enumerate(list(variations.items())[:10]):
                print(f"\n{i+1}. Base: {base}")
                for num in info['numbers']:
                    cases_with_num = [c for c in info['cases'] if c['numero_processo'] == num]
                    graus = [c['grau'] for c in cases_with_num]
                    print(f"   {num}: {', '.join(set(graus))}")
        
        return len(variations)
    
    def investigate_tribunal_specific_patterns(self, cases):
        """Investiga padr√µes espec√≠ficos por tribunal."""
        print(f"\nüèõÔ∏è INVESTIGA√á√ÉO POR TRIBUNAL")
        print("=" * 40)
        
        # Organiza por tribunal e grau
        tribunal_data = defaultdict(lambda: defaultdict(list))
        
        for case in cases:
            tribunal = case['tribunal']
            grau = case['grau']
            tribunal_data[tribunal][grau].append(case)
        
        # Foca nos principais tribunais
        main_tribunals = ['TRT2', 'TRT15', 'TRT4', 'TST']
        
        for tribunal in main_tribunals:
            if tribunal in tribunal_data:
                print(f"\nüèõÔ∏è {tribunal}:")
                for grau in ['G1', 'G2', 'SUP']:
                    if grau in tribunal_data[tribunal]:
                        count = len(tribunal_data[tribunal][grau])
                        print(f"  {grau}: {count:,} casos")
                        
                        # Mostra alguns n√∫meros de exemplo
                        examples = tribunal_data[tribunal][grau][:3]
                        for ex in examples:
                            print(f"    Ex: {ex['numero_processo']}")
        
        # Verifica se TST tem n√∫meros que tamb√©m aparecem nos TRTs
        tst_numbers = set()
        trt_numbers = set()
        
        for case in cases:
            numero = case['numero_processo']
            if case['tribunal'] == 'TST':
                tst_numbers.add(numero)
            elif case['tribunal'].startswith('TRT'):
                trt_numbers.add(numero)
        
        common_numbers = tst_numbers & trt_numbers
        print(f"\nüîó N√öMEROS COMUNS TST ‚Üî TRT: {len(common_numbers)}")
        
        if common_numbers:
            print("Primeiros 5 n√∫meros comuns:")
            for i, numero in enumerate(list(common_numbers)[:5]):
                print(f"  {i+1}. {numero}")
                
                # Mostra onde aparece
                tst_cases = [c for c in cases if c['numero_processo'] == numero and c['tribunal'] == 'TST']
                trt_cases = [c for c in cases if c['numero_processo'] == numero and c['tribunal'].startswith('TRT')]
                
                print(f"     TST: {[c['grau'] for c in tst_cases]}")
                for trt_case in trt_cases:
                    print(f"     {trt_case['tribunal']}: {trt_case['grau']}")
        
        return len(common_numbers)
    
    def investigate_sampling_issue(self, cases):
        """Investiga se h√° problema de amostragem."""
        print(f"\nüéØ INVESTIGA√á√ÉO DE PROBLEMAS DE AMOSTRAGEM")
        print("=" * 50)
        
        # Verifica distribui√ß√£o por arquivo de origem
        by_file = defaultdict(list)
        for case in cases:
            arquivo = case.get('arquivo_origem', 'unknown')
            by_file[arquivo].append(case)
        
        print(f"N√∫mero de arquivos de origem: {len(by_file)}")
        
        # Mostra distribui√ß√£o
        sorted_files = sorted(by_file.items(), key=lambda x: len(x[1]), reverse=True)[:10]
        print("\nTop 10 arquivos por n√∫mero de casos:")
        for arquivo, casos in sorted_files:
            graus = [c['grau'] for c in casos]
            grau_counts = {g: graus.count(g) for g in set(graus)}
            print(f"  {arquivo}: {len(casos):,} casos | {grau_counts}")
        
        # Verifica se h√° arquivos TST separados dos TRT
        tst_files = [f for f in by_file.keys() if 'tst' in f.lower()]
        trt_files = [f for f in by_file.keys() if 'trt' in f.lower()]
        
        print(f"\nArquivos TST: {len(tst_files)}")
        print(f"Arquivos TRT: {len(trt_files)}")
        
        if tst_files:
            print("Arquivos TST encontrados:")
            for f in tst_files[:5]:
                print(f"  - {f}")
        
        return {
            'total_files': len(by_file),
            'tst_files': len(tst_files),
            'trt_files': len(trt_files)
        }
    
    def generate_investigation_report(self, exact_results, variations_count, common_numbers_count, sampling_results):
        """Gera relat√≥rio da investiga√ß√£o."""
        from datetime import datetime
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        report = f"""# Investiga√ß√£o de Matching por N√∫meros Exatos

**Data**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## üéØ Objetivo
Investigar por que n√£o encontramos o mesmo n√∫mero de processo nas tr√™s inst√¢ncias (G1‚ÜíG2‚ÜíTST).

## üìä Resultados da Investiga√ß√£o

### N√∫meros Exatos
- **Total de n√∫meros √∫nicos**: {exact_results['total_numbers']:,}
- **N√∫meros em m√∫ltiplas inst√¢ncias**: {exact_results['multi_instance_count']:,}
- **Cadeias completas G1‚ÜíG2‚ÜíTST**: {exact_results['complete_chains']:,}

### Padr√µes de Cadeia Encontrados
"""
        
        for pattern, count in exact_results['chain_patterns'].items():
            percent = (count / exact_results['multi_instance_count']) * 100 if exact_results['multi_instance_count'] > 0 else 0
            report += f"- **{pattern}**: {count:,} ({percent:.1f}%)\n"
        
        report += f"""

### Problemas Identificados
- **Varia√ß√µes sutis nos n√∫meros**: {variations_count:,}
- **N√∫meros comuns TST‚ÜîTRT**: {common_numbers_count:,}
- **Arquivos TST separados**: {sampling_results['tst_files']}
- **Arquivos TRT**: {sampling_results['trt_files']}

## üö® Hip√≥teses para a Falta de Conex√µes

1. **Fragmenta√ß√£o por tribunal**: Cada tribunal salva apenas seus pr√≥prios casos
2. **Numera√ß√£o diferente**: TST pode usar numera√ß√£o diferente para recursos
3. **Filtros de coleta**: Pode haver filtros que separam as inst√¢ncias
4. **Per√≠odo de coleta**: Dados podem ter sido coletados em momentos diferentes

## üí° Pr√≥ximos Passos

1. Verificar se DataJud separa dados por tribunal/inst√¢ncia
2. Investigar se TST usa numera√ß√£o espec√≠fica para recursos
3. Analisar per√≠odo de coleta dos dados
4. Validar com especialista em direito trabalhista
"""
        
        # Salva relat√≥rio
        report_path = f"{self.output_path}/exact_matching_report_{timestamp}.md"
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(report)
        
        # Salva dados detalhados
        data_path = f"{self.output_path}/detailed_data_{timestamp}.json"
        detailed_data = {
            'exact_results': exact_results,
            'variations_count': variations_count,
            'common_numbers_count': common_numbers_count,
            'sampling_results': sampling_results
        }
        with open(data_path, 'w', encoding='utf-8') as f:
            json.dump(detailed_data, f, indent=2, ensure_ascii=False)
        
        print(f"\nüìÑ Relat√≥rio salvo: {report_path}")
        return report_path
    
    def run_investigation(self, csv_file):
        """Executa investiga√ß√£o completa."""
        print("üîç INVESTIGA√á√ÉO DE MATCHING POR N√öMEROS EXATOS")
        print("=" * 60)
        
        # Carrega dados
        cases = self.load_data(csv_file)
        
        # Investiga n√∫meros exatos
        exact_results = self.investigate_exact_number_matches(cases)
        
        # Analisa varia√ß√µes
        variations_count = self.analyze_number_variations(cases)
        
        # Investiga padr√µes por tribunal
        common_numbers_count = self.investigate_tribunal_specific_patterns(cases)
        
        # Investiga problemas de amostragem
        sampling_results = self.investigate_sampling_issue(cases)
        
        # Gera relat√≥rio
        report_path = self.generate_investigation_report(
            exact_results, variations_count, common_numbers_count, sampling_results
        )
        
        print(f"\nüìä RESUMO FINAL:")
        print("=" * 30)
        print(f"Cadeias G1‚ÜíG2‚ÜíTST: {exact_results['complete_chains']:,}")
        print(f"Multi-inst√¢ncia: {exact_results['multi_instance_count']:,}")
        print(f"N√∫meros comuns TST‚ÜîTRT: {common_numbers_count:,}")
        
        return exact_results

def main():
    """Fun√ß√£o principal."""
    investigator = ExactNumberMatcher()
    investigator.run_investigation("consolidated_all_data.csv")

if __name__ == "__main__":
    main()